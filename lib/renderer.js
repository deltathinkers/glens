// Generated by CoffeeScript 1.4.0
var Renderer, autoRotate;

autoRotate = false;

Renderer = (function() {

  Renderer.prototype.refreshSize = function() {
    var height, width;
    width = $(this.container).width();
    height = $(this.container).height();
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(width, height);
    if (this.effectFXAA) {
      this.effectFXAA.uniforms['resolution'].value.set(1 / width, 1 / height);
    }
    this.controls.handleResize();
    return this.composer.reset();
  };

  Renderer.prototype.onGcodeLoaded = function(gcode) {
    var gcodeObj;
    this.gr = new GCodeRenderer;
    this.gm = ParseGCode(gcode);
    gcodeObj = this.gr.render(this.gm);
    window.gr = this.gr;
    window.r = this;
    this.ui.controllers.gcodeIndex.max(this.gr.viewModels.length - 1);
    this.ui.controllers.gcodeIndex.setValue(0);
    this.ui.controllers.animate.setValue(true);
    this.camera.position.z = 500;
    this.camera.position.y = -1500;
    this.camera.lookAt(this.gr.center);
    console.log(gr);
    if (this.object) {
      this.scene.remove(this.object);
    }
    this.object = gcodeObj;
    return this.scene.add(this.object);
  };

  Renderer.prototype.setupStats = function() {
    this.stats = new Stats;
    this.stats.domElement.style.position = 'absolute';
    this.stats.domElement.style.top = '0px';
    return this.container.appendChild(this.stats.domElement);
  };

  Renderer.prototype.init = function() {
    var aspect, conf, effectScreen;
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({
      clearColor: 0x000000,
      clearAlpha: 1,
      antialias: false
    });
    this.renderer.autoClear = false;
    this.container.appendChild(this.renderer.domElement);
    conf = {
      fov: 45,
      near: 1,
      far: 10000,
      z: 300
    };
    aspect = window.innerWidth / window.innerHeight;
    console.log(aspect);
    this.camera = new THREE.PerspectiveCamera(conf.fov, aspect, conf.near, conf.far);
    this.camera.position.z = conf.z;
    this.scene.add(this.camera);
    this.controls = new THREE.TrackballControls(this.camera);
    this.controls.dynamicDampingFactor = 0.1;
    this.controls.rotateSpeed = 1.0;
    this.composer = new THREE.EffectComposer(this.renderer);
    this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
    effectScreen = new THREE.ShaderPass(THREE.ShaderExtras["screen"]);
    effectScreen.renderToScreen = true;
    this.composer.addPass(effectScreen);
    this.refreshSize();
    addEventListener('resize', this.refreshSize.bind(this));
    addEventListener('keydown', function(e) {
      if (e.keyCode === 32) {
        return autoRotate = !autoRotate;
      }
    });
    return this.setupStats();
  };

  function Renderer(container, ui) {
    this.container = container;
    this.ui = ui;
    this.init();
    this.animate();
  }

  Renderer.prototype.animate = function() {
    setTimeout(this.animate.bind(this), 100);
    this.render();
    if (this.stats) {
      return this.stats.update();
    }
  };

  Renderer.prototype.render = function() {
    var object, time, _i, _len, _ref;
    time = Date.now() * 0.0005;
    _ref = this.scene.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      if (autoRotate && object instanceof THREE.Object3D) {
        object.rotation.y = object.rotation.y + 0.015;
      }
    }
    if (window.effectController && this.gr) {
      if (window.effectController.animate) {
        try {
          this.gr.setIndex(this.gr.index + 1);
          window.effectController.gcodeIndex = this.gr.index;
        } catch (e) {
          window.effectController.animate = false;
          throw e;
        }
      } else {
        this.gr.setIndex(window.effectController.gcodeIndex);
      }
    }
    this.controls.update();
    this.renderer.clear();
    return this.composer.render();
  };

  return Renderer;

})();

window.Renderer = Renderer;
