// Generated by CoffeeScript 1.4.0
var Renderer, autoRotate;

autoRotate = false;

Renderer = function(container, ui) {
  var animate, aspect, conf, effectScreen, refreshSize, setupStats,
    _this = this;
  this.container = container;
  this.ui = ui;
  refreshSize = function() {
    var height, width;
    width = $(_this.container).width();
    height = $(_this.container).height();
    _this.camera.aspect = width / height;
    _this.camera.updateProjectionMatrix();
    _this.renderer.setSize(width, height);
    if (_this.effectFXAA) {
      _this.effectFXAA.uniforms['resolution'].value.set(1 / width, 1 / height);
    }
    _this.controls.handleResize();
    return _this.composer.reset();
  };
  setupStats = function() {
    _this.stats = new Stats;
    _this.stats.domElement.style.position = 'absolute';
    _this.stats.domElement.style.top = '0px';
    return _this.container.appendChild(_this.stats.domElement);
  };
  animate = function() {
    requestAnimationFrame(animate.bind(_this));
    _this.render();
    if (_this.stats) {
      return _this.stats.update();
    }
  };
  this.refreshObject = function() {
    return this.gr.refresh();
  };
  this.onGcodeLoaded = function(gcodeModel) {
    var gcodeObj;
    _this.gr = new GCodeRenderer;
    gcodeObj = _this.gr.render(gcodeModel);
    window.gr = _this.gr;
    window.r = _this;
    _this.ui.controllers.gcodeIndex.max(_this.gr.modelViews.length - 1);
    _this.ui.controllers.gcodeIndex.setValue(0);
    _this.ui.controllers.animate.setValue(true);
    _this.camera.position.z = 500;
    _this.camera.position.y = -1500;
    _this.camera.lookAt(_this.gr.getCenter());
    if (_this.object) {
      _this.scene.remove(_this.object);
    }
    _this.object = gcodeObj;
    return _this.scene.add(_this.object);
  };
  this.render = function() {
    var object, time, _i, _len, _ref;
    time = Date.now() * 0.0005;
    _ref = this.scene.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      if (autoRotate && object instanceof THREE.Object3D) {
        object.rotation.y = object.rotation.y + 0.015;
      }
    }
    this.controls.update();
    this.renderer.clear();
    return this.composer.render();
  };
  this.scene = new THREE.Scene();
  this.renderer = new THREE.WebGLRenderer({
    clearColor: 0x000000,
    clearAlpha: 1,
    antialias: false
  });
  this.renderer.autoClear = false;
  this.container.appendChild(this.renderer.domElement);
  [[0, 0, 1, 0xFFFFCC], [0, 1, 0, 0xFFCCFF], [1, 0, 0, 0xFFFFFF], [0, 0, -1, 0xCCCCFF], [0, -1, 0, 0xCCFFCC], [-1, 0, 0, 0xFFCCCC]].forEach(function(position) {
    var light;
    light = new THREE.DirectionalLight(position[3]);
    light.position.set(position[0], position[1], position[2]).normalize();
    return _this.scene.add(light);
  });
  conf = {
    fov: 45,
    near: 1,
    far: 10000,
    z: 300
  };
  aspect = window.innerWidth / window.innerHeight;
  console.log(aspect);
  this.camera = new THREE.PerspectiveCamera(conf.fov, aspect, conf.near, conf.far);
  this.camera.position.z = conf.z;
  this.scene.add(this.camera);
  this.controls = new THREE.TrackballControls(this.camera);
  this.controls.dynamicDampingFactor = 0.1;
  this.controls.rotateSpeed = 1.0;
  this.composer = new THREE.EffectComposer(this.renderer);
  this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
  effectScreen = new THREE.ShaderPass(THREE.CopyShader);
  effectScreen.renderToScreen = true;
  this.composer.addPass(effectScreen);
  refreshSize();
  addEventListener('resize', refreshSize);
  addEventListener('keydown', function(e) {
    if (e.keyCode === 32) {
      return autoRotate = !autoRotate;
    }
  });
  setupStats();
  return animate();
};

window.Renderer = Renderer;
